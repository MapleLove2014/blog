---
title: ZigZag转换解法和优化
author: ZhangMapler
date: 2020-06-22 11:31:00 +0800
categories: [LeetCode]
tags: [python, algorithm]
math: true
---

# ZigZag转换问题[Medium]

## 问题描述

将一个字符串通过ZigZag转换后的结果返回，[官网具体描述点这里](https://leetcode.com/problems/zigzag-conversion/) .

> 第一遍看官方的题目描述，没太看懂，要多看几遍，最好自己找几个例子自己画一下。

我们以 `ABCDEFGHIJKLMN` , `rows=4` 为例，如下图：

```
A     G      M
B   F H    L N      ->     AGMBFHLNCEIKDJ
C E   I  K  
D     J
```

可以观察到转换的主要过程为将源字符串按列存放，按行读出。其中：

1. 两个完整列和中间的对角线构成一个平躺的水平对称的 `Z` 形状

2. 两个完整列中间有一个长度为 `rows - 2` 的 `正方形`，其中对角线上逆序存放字符

再看下base case：

1. 当字符串长度不超过2时，无需转换

2. 当 `rows=1` 时，无需转换

3. 当 `rows=2` 时，`正方形` 长度为0，逻辑和 `rows > 2` 保持一致

## 简单粗暴版解法

根据上述观察和转换特点，可以设计出一个简单粗暴直接的方法：

1. 用一个二维数组按列存放转换结果，初始填充一个placeholder，比如 `-1` 或者 `0` 等

2. 通过列索引计算当前列是否在`正方形`中
    
    ```python
        False if j % (rows - 2 + 1) == 0 else True
    ```

    2.1 如果列不在正方形中，按列依次存放字符至当前列，当存到最后一行时，移至下一列

    2.2 否则，根据正方形的性质计算出当前列存放数据的行索引 `table[rows - 1 - j % (rows - 2 + 1)][j]`, 存入字符

3. 转换完成后，按行遍历，过滤掉placeholder，进行拼接返回

> 实现时注意索引的变化，循环的退出条件

代码如下：
```python
def convert(self, s: str, numRows: int) -> str:
    # base case
    if not s or len(s) <= 2 or numRows <= 1:
        return s

    # 初始化，字符0填充
    table = [['0' for _ in range(len(s))] for _ in range(numRows)]

    # 源字符串遍历索引
    sIndex = 0
    # 中间正方形长度
    innerLength = numRows - 2

    # 列遍历索引
    j = 0
    while j < len(s):
        # 行遍历索引
        i = 0
        while i < numRows:
            if sIndex >= len(s):
                break
            # 完整列数据填充
            if j % (innerLength + 1) == 0:
                table[i][j] = s[sIndex]
                sIndex += 1
                # 填充到最后列的最后一个元素，移动到下一列
                if i == numRows - 1:
                    j += 1
                i += 1
            # 正方形对角线数据填充
            else:
                table[numRows - 1 - j % (innerLength + 1)][j] = s[sIndex]
                sIndex += 1
                j += 1

        if sIndex >= len(s):
            break
    # 组装结果
    ss = []
    for i in range(numRows):
        for jj in range(len(s)):
            if table[i][jj] != '0':
                ss.append(table[i][jj])

    return ''.join(ss)

```

首先分析下此实现的时间和空间复杂度：

1. 双 `while` 循环的访问路径如下图所示，访问数组元素的次数为字符串的长度，时间复杂度UpperBound为 `O(n)`

2. 组装结果的双层 `for` 循环访问了二维数组的所有元素，时间复杂度UpperBound为 $$ O(n^2) $$